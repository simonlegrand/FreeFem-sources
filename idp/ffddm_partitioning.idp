load "scotch"
load "metis"

/*# beginPartition #*/
macro ffddmbuildDmeshf(prmesh, Th, partdof, sizeoverlaps)
if (prmesh#isincomm)
{	
  prmesh#tic(prmesh#tdecompi)
  if (!prmesh#excluded) {
    int backup = searchMethod;
    searchMethod = 1;

    int ssplit = max(prmesh#inexactCSsplit,1);

    prmesh#overlap = sizeoverlaps*ssplit;

    if (prmesh#npart == 1) {
      if (ffddmsplit*ssplit == 1)
        prmesh#Thi = Th;
      else
        prmesh#Thi=trunc(Th,1,split=ssplit*ffddmsplit);                 /* freefem's trick, formal definition*/

      prmesh#aTh[0]=prmesh#Thi;
      real[int] one(prmesh#VhiP1.ndof);
      one=1.;
      prmesh#RihP1[0]=one;
      prmesh#DP1[0]=1.;
      prmesh#partloc.resize(partdof.n);
      prmesh#partloc = partdof;
    }
    else 
    for(int ii=0;ii<prmesh#npart;++ii)
    if ((!bpara) || (ii == mpiRank(prmesh#commddm))) {
      
      int[int] arrayIntersectioni;
      
      int numberIntersectioni = 0;
      
      prmesh#meshN overlapName=Th;
      fespace VhGlobalff(overlapName, P1);
      fespace PhGlobalff(overlapName, P0);
      PhGlobalff part;
      part[]=partdof;
      
      PhGlobalff supp = abs(part - ii) < 0.1;
      VhGlobalff suppSmooth;
      AddLayers(overlapName, supp[], (sizeoverlaps == 0) + sizeoverlaps * 2, suppSmooth[]);
      {   
        prmesh#meshN neighbors = trunc(overlapName, suppSmooth > 0.001 && (suppSmooth < 0.999));
        fespace Oh(neighbors, P0);
        Oh partOverlap = part;
        
        Unique(partOverlap[], arrayIntersectioni);          
        
      }
      
      prmesh#VhiP1[int] partitionIntersectioni(arrayIntersectioni.n);
      prmesh#partitionIntersectionbasei.resize(arrayIntersectioni.n);

      IFMACRO(!prmesh#partcubes)
      if(ffddmsplit>1) {
        overlapName = trunc(overlapName, suppSmooth > 0.001, split = ffddmsplit, label=9999);
        supp = abs(part - ii) < 0.1;
        suppSmooth = 0;
        AddLayers(overlapName, supp[], (sizeoverlaps == 0) + 2 * sizeoverlaps, suppSmooth[]);
      }
      ENDIFMACRO

      prmesh#Thi = trunc(overlapName, suppSmooth > 0.001, split=ssplit);
      IFMACRO(prmesh#partcubes,1)
      real[int] bbg(6);
      boundingbox(overlapName,bbg);
      ENDIFMACRO
      overlapName = trunc(overlapName, suppSmooth > 0.001, label=9999);

      supp = supp;
      suppSmooth = suppSmooth;

      prmesh#meshN borderName;
      if (sizeoverlaps > 0) {

        IFMACRO(prmesh#partcubes,1)
        prmesh#Thi=trunc(overlapName, abs(part - ii) < 0.1, label = 9999);
        real[int] bb(6);
        boundingbox(prmesh#Thi,bb);

        int[int] labs(6), labsi(6);
        labs = 0;
        int samex, samey, samez;

        for (int ii=0; ii<prmesh#Thi.nbe; ii++) {
          IFMACRO(dimension,2)
          samex = (prmesh#Thi.be(ii)[0].x == prmesh#Thi.be(ii)[1].x);
          samey = (prmesh#Thi.be(ii)[0].y == prmesh#Thi.be(ii)[1].y);
          ENDIFMACRO
          IFMACRO(dimension,3)
          samex = (prmesh#Thi.be(ii)[0].x == prmesh#Thi.be(ii)[1].x) && (prmesh#Thi.be(ii)[1].x == prmesh#Thi.be(ii)[2].x);
          samey = (prmesh#Thi.be(ii)[0].y == prmesh#Thi.be(ii)[1].y) && (prmesh#Thi.be(ii)[1].y == prmesh#Thi.be(ii)[2].y);
          samez = (prmesh#Thi.be(ii)[0].z == prmesh#Thi.be(ii)[1].z) && (prmesh#Thi.be(ii)[1].z == prmesh#Thi.be(ii)[2].z);
          ENDIFMACRO
          if (prmesh#Thi.be(ii).label != 9999) {
                 if (samex && prmesh#Thi.be(ii)[0].x == bb[0]) labs[0] = prmesh#Thi.be(ii).label;
            else if (samex && prmesh#Thi.be(ii)[0].x == bb[1]) labs[1] = prmesh#Thi.be(ii).label;
            else if (samey && prmesh#Thi.be(ii)[0].y == bb[2]) labs[2] = prmesh#Thi.be(ii).label;
            else if (samey && prmesh#Thi.be(ii)[0].y == bb[3]) labs[3] = prmesh#Thi.be(ii).label;
            IFMACRO(dimension,3)
            else if (samez && prmesh#Thi.be(ii)[0].z == bb[4]) labs[4] = prmesh#Thi.be(ii).label;
            else if (samez && prmesh#Thi.be(ii)[0].z == bb[5]) labs[5] = prmesh#Thi.be(ii).label;
            ENDIFMACRO
          }
        }

        IFMACRO(dimension,2)
        real p0x = prmesh#Thi(prmesh#Thi[0][0]).x, p0y = prmesh#Thi(prmesh#Thi[0][0]).y;
        real p1x = prmesh#Thi(prmesh#Thi[0][1]).x, p1y = prmesh#Thi(prmesh#Thi[0][1]).y;
        real p2x = prmesh#Thi(prmesh#Thi[0][2]).x, p2y = prmesh#Thi(prmesh#Thi[0][2]).y;
        real h = min(sqrt((p1x-p0x)^2+(p1y-p0y)^2),sqrt((p2x-p0x)^2+(p2y-p0y)^2));
        ENDIFMACRO
        IFMACRO(dimension,3)
        real p0x = prmesh#Thi(prmesh#Thi.be(0)[0]).x, p0y = prmesh#Thi(prmesh#Thi.be(0)[0]).y, p0z = prmesh#Thi(prmesh#Thi.be(0)[0]).z;
        real p1x = prmesh#Thi(prmesh#Thi.be(0)[1]).x, p1y = prmesh#Thi(prmesh#Thi.be(0)[1]).y, p1z = prmesh#Thi(prmesh#Thi.be(0)[1]).z;
        real p2x = prmesh#Thi(prmesh#Thi.be(0)[2]).x, p2y = prmesh#Thi(prmesh#Thi.be(0)[2]).y, p2z = prmesh#Thi(prmesh#Thi.be(0)[2]).z;
        real h = min(sqrt((p1x-p0x)^2+(p1y-p0y)^2+(p1z-p0z)^2), sqrt((p2x-p0x)^2+(p2y-p0y)^2+(p2z-p0z)^2));
        ENDIFMACRO

        h /= ffddmsplit;

        bb[0] -= h*sizeoverlaps*(!labs[0]); bb[2] -= h*sizeoverlaps*(!labs[2]); bb[4] -= h*sizeoverlaps*(!labs[4]);
        bb[1] += h*sizeoverlaps*(!labs[1]); bb[3] += h*sizeoverlaps*(!labs[3]); bb[5] += h*sizeoverlaps*(!labs[5]);
        bb[0] = max(bb[0],bbg[0]); bb[2] = max(bb[2],bbg[2]); bb[4] = max(bb[4],bbg[4]);
        bb[1] = min(bb[1],bbg[1]); bb[3] = min(bb[3],bbg[3]); bb[5] = min(bb[5],bbg[5]);

        labsi = labs ? labs : ffddmcubelabels;

        IFMACRO(dimension,2)
        int[int] L = [labsi[2],labsi[1],labsi[3],labsi[0]];
        prmesh#Thi = square(rint((bb[1]-bb[0])/h),rint((bb[3]-bb[2])/h),[x*(bb[1]-bb[0])+bb[0],y*(bb[3]-bb[2])+bb[2]],label=L);
        ENDIFMACRO
        IFMACRO(dimension,3)
        include "cube.idp"
        int[int] NN=[rint((bb[1]-bb[0])/h), rint((bb[3]-bb[2])/h), rint((bb[5]-bb[4])/h)];
        real [int,int] BB=[[bb[0],bb[1]],[bb[2],bb[3]],[bb[4],bb[5]]];
        int [int,int] L=[[labsi[0],labsi[1]],[labsi[2],labsi[3]],[labsi[4],labsi[5]]];
        prmesh#Thi = Cube(NN,BB,L);
        ENDIFMACRO

        bb[0] -= h*(!labs[0]); bb[2] -= h*(!labs[2]); bb[4] -= h*(!labs[4]);
        bb[1] += h*(!labs[1]); bb[3] += h*(!labs[3]); bb[5] += h*(!labs[5]);
        bb[0] = max(bb[0],bbg[0]); bb[2] = max(bb[2],bbg[2]); bb[4] = max(bb[4],bbg[4]);
        bb[1] = min(bb[1],bbg[1]); bb[3] = min(bb[3],bbg[3]); bb[5] = min(bb[5],bbg[5]);

        labsi = labs ? labs : (abs(ffddminterfacelabel) + 1) * 100;

        IFMACRO(dimension,2)
        int[int] Lb = [labsi[2],labsi[1],labsi[3],labsi[0]];
        borderName = square(rint((bb[1]-bb[0])/h),rint((bb[3]-bb[2])/h),[x*(bb[1]-bb[0])+bb[0],y*(bb[3]-bb[2])+bb[2]],label=Lb);
        ENDIFMACRO
        IFMACRO(dimension,3)
        int[int] NNb=[rint((bb[1]-bb[0])/h), rint((bb[3]-bb[2])/h), rint((bb[5]-bb[4])/h)];
        real [int,int] BBb=[[bb[0],bb[1]],[bb[2],bb[3]],[bb[4],bb[5]]];
        int [int,int] Lb=[[labsi[0],labsi[1]],[labsi[2],labsi[3]],[labsi[4],labsi[5]]];
        borderName = Cube(NNb,BBb,Lb);
        ENDIFMACRO

        fespace PhborderName(borderName,P0);
        fespace Phii(prmesh#Thi,P0);
        matrix Riiborder = interpolate(Phii, PhborderName);
        Phii parti = 1;
        PhborderName partborder;
        partborder[] = Riiborder'*parti[];
        borderName = trunc(borderName, partborder==0, label = (abs(ffddminterfacelabel) + 1) * 100);

        overlapName = prmesh#Thi;
        supp = abs(part - ii) < 0.1;
        suppSmooth = suppSmooth;

        parti = part;
        prmesh#partloc.resize(Phii.ndof);
        prmesh#partloc = parti[];
        ENDIFMACRO

        IFMACRO(!prmesh#partcubes)
        prmesh#Thi = trunc(prmesh#Thi, suppSmooth> 0.501, label = ffddminterfacelabel);
        if (prmesh#Thi.nt != overlapName.nt)
          borderName = trunc(overlapName, (suppSmooth > (sizeoverlaps - 0.999) / (2 * sizeoverlaps)) && (suppSmooth < 0.501), label = (abs(ffddminterfacelabel) + 1) * 100);
        ENDIFMACRO
      }
      else {
        fespace fP0(prmesh#Thi,P0);
        fP0 part0 = part;
        prmesh#Thi = trunc(prmesh#Thi, abs(part - ii) < 0.1, label = ffddminterfacelabel);
        borderName = trunc(overlapName, suppSmooth < 0.999, label = (abs(ffddminterfacelabel) + 1) * 100);
      }
      
      prmesh#VhiP1 khi;
      if (sizeoverlaps > 0) {
        khi = max(suppSmooth*2 - 1.0, 0.);
        if(usedARGV("-whatname") != -1) {
          supp = abs(part - ii) < 0.1;
          AddLayers(overlapName, supp[], (sizeoverlaps == 0) + max(sizeoverlaps-1,1), suppSmooth[]);
          khi = suppSmooth;
        }
        else if(usedARGV("-steep") != -1)
          khi = khi > 0.001 ? 1.0 : 0.0;
        else if (usedARGV("-raspart") != -1) {
          VhGlobalff phir;
          PhGlobalff suppP0 = abs(ii - part) < 0.1;
          varf vSuppi(u,v) = prmesh#intN(overlapName,qforder=1)(suppP0*v);
          phir[] = vSuppi(0,VhGlobalff);
          phir = phir > 0.;
          khi = phir;
        }
      }
      else {
        khi[] = 1.;
      }
      
      prmesh#VhiP1 sum = khi;
      VhGlobalff phi = 0, phibase = 0;
      
      /*real eps=int2d(overlapName)(1.);*/
      real eps = prmesh#intN(overlapName)(1.0);
      real[int] epsn(arrayIntersectioni.n);
      if(bpara){ /* version for very ugly meshes, not implemented yet for bseq*/        
        mpiRequest[int] rqn(2*arrayIntersectioni.n);
        for(int j=0;j<arrayIntersectioni.n;++j)
        Isend(processor(arrayIntersectioni[j],prmesh#commddm,rqn[j*2]),eps);
        for(int j=0;j<arrayIntersectioni.n;++j)
        Irecv(processor(arrayIntersectioni[j],prmesh#commddm,rqn[j*2+1]),epsn[j]);
        for(int j=0;j<2*arrayIntersectioni.n;++j) {
          int k = mpiWaitAny(rqn);
        }
      }    
      for(int i = 0; i < arrayIntersectioni.n; ++i) {
        PhGlobalff suppPartition = abs(arrayIntersectioni[i] - part) < 0.1;
        
        PhGlobalff suppP0;
        suppP0[] = suppPartition[];
        if (sizeoverlaps > 0) {
          AddLayers(overlapName, suppPartition[], sizeoverlaps, phi[]);
          phibase[] = phi[];

          if(usedARGV("-whatname") != -1) {
            suppPartition = abs(arrayIntersectioni[i] - part) < 0.1;
            AddLayers(overlapName, suppPartition[], max(sizeoverlaps-1,1), phi[]);
          }
          else if(usedARGV("-steep") != -1)
            phi = phi > 0.001 ? 1.0 : 0.0;
          else if (usedARGV("-raspart") != -1) {
            VhGlobalff phir;
            varf vSuppi(u,v) = prmesh#intN(overlapName,qforder=1)(suppP0*v);
            phir[] = vSuppi(0,VhGlobalff);
            phir = phir > 0.;
            phi = phir;
          }
        }
        else {
          VhGlobalff phir;
          varf vSuppi(u,v) = prmesh#intN(overlapName,qforder=1)(suppP0*v);
          phir[] = vSuppi(0,VhGlobalff);
          phir = phir > 0.;
          phi = phir;
          phibase[] = phi[];
        }
        
        /*real intersection=prmesh#intN(overlapName)(phibase)/eps;*/
        /*if(arrayIntersectioni[i] <=1)*/
        real epsi=0;
        if(bpara){ /* version for very ugly meshes, not implemented yet for bseq */
          epsi = min(eps,epsn[i]);
        }
        else{
          epsi = eps;	
        }   
        real intersection;
        if (prmesh#overlap > 0)
          intersection = prmesh#intN(overlapName)(phibase) / epsi;
        else {
          partitionIntersectioni[numberIntersectioni] = phi;
          intersection = partitionIntersectioni[numberIntersectioni][].max;
        }
        if( intersection>1e-6)
        {
          partitionIntersectioni[numberIntersectioni] = phi;
          
          prmesh#partitionIntersectionbasei[numberIntersectioni] = phibase;
          
          sum[] += partitionIntersectioni[numberIntersectioni][];
          arrayIntersectioni[numberIntersectioni++] = arrayIntersectioni[i];
        }
        
      }
      
      khi[] = khi[] ./= sum[];

      overlapName = prmesh#minimalMesh;
      if(numberIntersectioni != arrayIntersectioni.n)
      arrayIntersectioni.resize(numberIntersectioni);  
      
      /* PoU for inexactsplit > 1 */
      if (prmesh#inexactCSsplit > 1) {
        
        fespace Phi(prmesh#Thi,P0);
        Phi suppP0i = abs(ii - part) < 0.1;
        varf vSuppii(u,v) = prmesh#intN(prmesh#Thi,qforder=1)(suppP0i*v);
        prmesh#VhiP1 phiri;
        phiri[] = vSuppii(0,prmesh#VhiP1);
        phiri = phiri > 0.; 
        
        prmesh#VhiP1 sumi = phiri;
        
        for(int i = 0; i < arrayIntersectioni.n; ++i) {    
          Phi suppP0n = abs(arrayIntersectioni[i] - part) < 0.1;
          varf vSuppin(u,v) = prmesh#intN(prmesh#Thi,qforder=1)(suppP0n*v);
          prmesh#VhiP1 phirn;
          phirn[] = vSuppin(0,prmesh#VhiP1);
          phirn = phirn > 0.; 
          sumi[] += phirn[];  
        }   
        
        khi[] = phiri[] ./= sumi[];      
      }
      
      if (bpara) {
        prmesh#numberIntersection = numberIntersectioni;
        prmesh#arrayIntersection.resize(prmesh#numberIntersection);
        prmesh#arrayIntersection = arrayIntersectioni;
      }
      
      if(!bnoGlob)
      {
        fespace prmesh#VhglobP1(prmesh#Thglob,P1);
        prmesh#RihP1[ii]=interpolate(prmesh#VhiP1,prmesh#VhglobP1);
        
        
        int[int] I(1),J(1);
        real[int] Kc(1);
        [I,J,Kc] = prmesh#RihP1[ii];
        for (int i=0;i<Kc.n;i++)
        if (Kc[i] > 0.99)
        Kc[i] = 1.;
        prmesh#RihP1[ii] = [I,J,Kc];
        
        prmesh#RihP1[ii].thresholding(1e-10);
        prmesh#RihP1[ii].resize(prmesh#VhiP1.ndof,prmesh#VhglobP1.ndof);
      }	
      
      prmesh#aTh[ii]=prmesh#Thi;
      prmesh#aThborder[ii]=trunc(borderName,1,split=ssplit);

      if (bpara && prmesh#overlap == 0) {
        IFMACRO(prmesh#mminoverlap,1)
        fespace prmesh#PhAugP0(prmesh#AugThi,P0);
        prmesh#PhAugP0 phaug = part;
        prmesh#partAug.resize(prmesh#PhAugP0.ndof);
        prmesh#partAug = phaug[];
        ENDIFMACRO
        IFMACRO(prmesh#mminoverlap,0)
        cout << "["+Stringification(prmesh)+"] ffddmbuildDmesh PB: you need to define macro \""+Stringification(prmesh)+"mminoverlap\" to 1 when using overlap=0, e.g. by adding \"-D"+Stringification(prmesh)+"mminoverlap=1\" to the command line" << endl;
        assert(0);
        ENDIFMACRO
        ;
      }

      prmesh#DP1[ii] = khi;

      if (!bnopartloc) {
        fespace Phii0(prmesh#Thi,P0);
        Phii0 prmesh#p0 = part;
        prmesh#partloc.resize(Phii0.ndof);
        prmesh#partloc = prmesh#p0[];
      }
    }
    searchMethod = backup;
  }

  if (bseq)
  prmesh#Thi = prmesh#Thglob;

  prmesh#toc(prmesh#tdecompi,"",prmesh#tdecomp)
} 
//EOM

macro ffddminitDmeshf(prmesh,comm)
IFMACRO(!prmesh#meshinit)

IFMACRO(((!prmesh#dim)&(dimension,2))|(prmesh#dim,2))
NewMacro prmesh#meshN()mesh EndMacro             /* two-dimensional problem  */
NewMacro prmesh#intN()int2d EndMacro             /* two-dimensional integral */
NewMacro prmesh#intbN()int1d EndMacro            /* one-dimensional integral */
NewMacro prmesh#minimalMesh()square(1,1) EndMacro
ENDIFMACRO

IFMACRO(((!prmesh#dim)&(dimension,3))|(prmesh#dim,3))
NewMacro prmesh#meshN()mesh3 EndMacro            /* three-dimensional problem  */
NewMacro prmesh#intN()int3d EndMacro             /* three-dimensional integral */
NewMacro prmesh#intbN()int2d EndMacro            /* two-dimensional integral   */
NewMacro prmesh#minimalMesh()cube(1,1,1) EndMacro
ENDIFMACRO

IFMACRO(((!prmesh#dim)&(dimension,3S))|(prmesh#dim,3S))
NewMacro prmesh#meshN()meshS EndMacro            /* three-dimensional surface problem */
NewMacro prmesh#intN()int2d EndMacro
NewMacro prmesh#intbN()int1d EndMacro
NewMacro prmesh#minimalMesh()square3(1,1,[x,y,z]) EndMacro
ENDIFMACRO

IFMACRO(((!prmesh#dim)&(dimension,3L))|(prmesh#dim,3L))
NewMacro prmesh#meshN()meshL EndMacro            /* three-dimensional line problem */
NewMacro prmesh#intN()int1d EndMacro
NewMacro prmesh#intbN()int0d EndMacro
NewMacro prmesh#minimalMesh()Sline(2,[x,y,z]) EndMacro
ENDIFMACRO

int prmesh#npart = ffddmnpart;

/*int prmesh#verbosity = ffddmverbosity;*/

real prmesh#tdecompi;
real prmesh#tdecomp = 0;

NewMacro prmesh#tic(tim) tim = mpiWtime(); EndMacro
NewMacro prmesh#toc(tim,msg,totaltime)
if (prmesh#isincomm)
{
  tim = mpiWtime() - tim;
  
  real ttimeg = 0;
  mpiAllReduce(tim,ttimeg,prmesh#mpicomm,mpiMAX);
  if ((mpiRank(prmesh#mpicomm) == 0) /*&& (prmesh#verbosity > 0)*/ && (msg != ""))
  cout << "["+Stringification(prmesh)+"] timings - " << msg << " : " << ttimeg << " s" << endl;
  totaltime += ttimeg;
  
  /*totaltime += tim;*/
}
EndMacro

NewMacro prmesh#toccomm(tim,msg,totaltime,comm)
if (prmesh#isincomm)
{
  tim = mpiWtime() - tim;
  
  real ttimeg = 0;
  mpiAllReduce(tim,ttimeg,comm,mpiMAX);
  if ((mpiRank(comm) == 0) && (msg != ""))
  cout << "["+Stringification(prmesh)+"] timings - " << msg << " : " << ttimeg << " s" << endl;
  totaltime += ttimeg;
  
  /*totaltime += tim;*/
}
EndMacro

prmesh#meshN prmesh#Thi = prmesh#minimalMesh;

fespace prmesh#VhiP1(prmesh#Thi,P1);

prmesh#VhiP1[int] prmesh#partitionIntersectionbasei(0);

int prmesh#overlap = 0;

int prmesh#numberIntersection = 0;

int[int] prmesh#arrayIntersection(0);

prmesh#meshN prmesh#Thglob = prmesh#minimalMesh;

matrix[int] prmesh#RihP1(prmesh#npart);
prmesh#VhiP1[int] prmesh#DP1(prmesh#npart);

NewMacro prmesh#mpicomm()comm EndMacro

int[int] prmesh#procddm = [mpirank];
int[int] prmesh#procCS = [mpirank];

int prmesh#isincomm = (mpiRank(comm) >= 0);

int prmesh#excluded = !prmesh#isincomm;

if (prmesh#isincomm) {
  int[int] globranks(mpiSize(comm));
  int myglobrank = mpirank;
  
  mpiAllgather(myglobrank,globranks,comm);
  
  if ((prmesh#pCS > 1) && (mpiRank(comm) < prmesh#pCS)) {
    prmesh#procCS.resize(prmesh#pCS);
    for (int i=0; i<prmesh#pCS;i++)
    prmesh#procCS[i] = globranks[i];
  }
  
  if (!prmesh#exclude) {
    prmesh#procddm.resize(mpiSize(comm));
    if (mpiSize(comm) > 1)
    for (int i=0; i<mpiSize(comm);i++)
    prmesh#procddm[i] = globranks[i];
    else
    prmesh#procddm = [mpirank];
  }
  else {
    prmesh#procddm.resize(mpiSize(comm)-prmesh#pCS);
    if (mpiSize(comm) > 1)
    for (int i=0; i<mpiSize(comm)-prmesh#pCS;i++)
    prmesh#procddm[i] = globranks[i+prmesh#pCS];
    else
    prmesh#procddm = [mpirank];
    if (mpiRank(comm) < prmesh#pCS)
    prmesh#excluded = 1;
  }
}

mpiGroup prmesh#grpddm(prmesh#procddm);
mpiComm prmesh#commddm(mpiCommWorld,prmesh#grpddm);
mpiGroup prmesh#grpCS(prmesh#procCS);
mpiComm prmesh#commCS(mpiCommWorld,prmesh#grpCS);

int[int] prmesh#procself = [mpiRank(mpiCommWorld)];
mpiGroup prmesh#grpself(prmesh#procself);
mpiComm prmesh#commself(mpiCommWorld,prmesh#grpself);

/*  Domain decomposition data structures */
prmesh#meshN[int] prmesh#aTh(prmesh#npart);        /* sequence of ovr. meshes */
prmesh#meshN[int] prmesh#aThborder(prmesh#npart);

real[int] prmesh#partAug(1);
real[int] prmesh#partloc(1);

NewMacro prmesh#meshinit()1 EndMacro
ENDIFMACRO
// EOM

macro ffddmpartf(prmesh,Th,sizeoverlaps,res)
{
  prmesh#tic(prmesh#tdecompi)
  
  fespace prmesh#Ph0(Th,P0);
  prmesh#Ph0 upart;                                  /* piecewise constant function */
  
  if (bpara){
    if (!prmesh#excluded && mpiRank(prmesh#commddm)==0 && (prmesh#npart != mpiSize(prmesh#commddm))) {
      cout << "bpara option PB: npart==" << prmesh#npart << " != mpiSize(commddm)==" << mpiSize(prmesh#commddm) << endl;
      assert(prmesh#npart == mpiSize(prmesh#commddm));
    }
  }
  
  if(!prmesh#excluded) {
    if (prmesh#npart == 1) {
      upart[] = 0.; 
    }
    else if(ffddmpartitioner != 0) {
      if(ffddmpartitioner == 2) {
        if (mpiRank(prmesh#commddm) == 0) {
          int[int] lpart(prmesh#Ph0.ndof);
          scotch(lpart,Th,prmesh#npart);
          for(int i=0;i<lpart.n;++i)
          upart[][i]=lpart[i];    
        }   
      }
      else {
        if (mpiRank(prmesh#commddm) == 0) {
          int[int] lpart(prmesh#Ph0.ndof);
          metisdual(lpart,Th,prmesh#npart);
          for(int i=0;i<lpart.n;++i)
          upart[][i]=lpart[i];
        }   
      }
      int nomesh = (Th.nt == 0);
      int[int] nomeshtab(mpiSize(prmesh#commddm));
      mpiAllgather(nomesh,nomeshtab,prmesh#commddm);
      if (!nomeshtab.max)
        broadcast(processor(0, prmesh#commddm), upart[]);
      else {
        assert(bnoGlob);
        if (mpiRank(prmesh#commddm) == 0) {
          prmesh#Ph0 supp;
          fespace prmesh#Ph1(Th,P1);
          prmesh#Ph1 suppSmooth;
          mpiRequest[int] rq(2*nomeshtab.sum + (prmesh#npart-nomeshtab.sum-1));
          int cpt = 0;
          for (int i=1; i<mpiSize(prmesh#commddm); i++)
          if (nomeshtab[i]) {
            supp = abs(upart - i) < 0.1;
            AddLayers(Th, supp[], (sizeoverlaps == 0) + sizeoverlaps * 2, suppSmooth[]);
            int[int] n2o(1);
            prmesh#meshN Thiovl = trunc(Th, suppSmooth > 0.001, label=9999, new2old = n2o);
            Isend(processor(i,prmesh#commddm,rq[cpt]),Thiovl);
            mpiWait(rq[cpt++]);
            fespace prmesh#Ph0i(Thiovl,P0);
            int[int] renum = restrict(prmesh#Ph0i, prmesh#Ph0, n2o);
            prmesh#Ph0i uparti;
            uparti[] = upart[](renum);
            Isend(processor(i,prmesh#commddm,rq[cpt]),uparti[]);
            mpiWait(rq[cpt++]);
          }
          else {
            Isend(processor(i,prmesh#commddm,rq[cpt]),upart[]);
            mpiWait(rq[cpt++]);
          }
        }
        else {
          mpiRequest[int] rq(2);
          if (!Th.nt) {
            Irecv(processor(0,prmesh#commddm,rq[0]),Th);
            mpiWait(rq[0]);
            upart = 0;
          }
          Irecv(processor(0,prmesh#commddm,rq[1]),upart[]);
          mpiWait(rq[1]);
        }
      }
    }
    else {
      IFMACRO (!prmesh#simple)
      if (mpiRank(prmesh#commddm) == 0)
      cout << "["+Stringification(prmesh)+"] partitioner option PB: you must declare a \'"+Stringification(prmesh)+"simple\' partitioning macro when using ffddmpartitioner = 0" << endl;
      assert(0);
      ENDIFMACRO
      IFMACRO (prmesh#simple)
      prmesh#simple(prmesh#Ph0, upart, prmesh#commddm)
      ENDIFMACRO
    }    	
    
    if (ffddmbplot && (mpiRank(prmesh#commddm) == 0 && ffddmverbosity >= 5)) {
      if (ffddmbffplot)
      plot(upart,wait=0,cmm="partition",value=1,fill=1);
      if (ffddmbmedit)
      medit("partition",Th,upart);
    }
    
    res.resize(upart[].n);
    res = upart[];
  }
  
  prmesh#toc(prmesh#tdecompi,"",prmesh#tdecomp)
}
// EOM

macro ffddminitDfespacef(prfe,prmsh,scalar,udef,uinit,mPk,udefpart,uinitpart,mPkP0)
IFMACRO(!prfe#feinit)
NewMacro prfe#prmesh()prmsh EndMacro

NewMacro prfe#K scalar EndMacro
NewMacro prfe#mdef udef EndMacro
NewMacro prfe#minit uinit EndMacro

NewMacro prfe#mdefpart udefpart EndMacro
NewMacro prfe#minitpart uinitpart EndMacro

NewMacro prfe#fPk mPk EndMacro
NewMacro prfe#fPkP0 mPkP0 EndMacro

fespace prfe#Vhi(prmsh#Thi,prfe#fPk);

fespace prfe#Vhglob(prmsh#Thglob,prfe#fPk);

prfe#K[int][int] prfe#Dk(prmsh#npart);

matrix<prfe#K>[int] prfe#Rih(prmsh#npart);               /* local restriction operators  */
matrix<prfe#K>[int] prfe#Dih(prmsh#npart);               /* partition of unity operators */

matrix<prfe#K>[int] prfe#restrictionIntersection(0);

/* communication buffers */
prfe#K[int][int] prfe#rcv(0);
prfe#K[int][int] prfe#snd(0);

int prfe#Ndofglobal = 0;

IFMACRO(prmsh#buildAug,1)
matrix prfe#Auginterp;
ENDIFMACRO

/* Update u_i = R_i sum_j (R_j' u_j)
   if (scale) u_i = R_i sum_j (R_j' D_j u_j)
   using communication buffers in the overlap */
func int prfe#update(scalar[int] vv, bool scale)
{
  if (!prmsh#excluded)
  {
    if (scale)
      vv = vv .* prfe#Dk[mpiRank(prmsh#commddm)];
    mpiRequest[int] rq(prmsh#numberIntersection*2);
    for(int j=0;j<prmsh#numberIntersection;++j)
      prfe#snd[j] = prfe#restrictionIntersection[j]*vv;
    for(int j=0;j<prmsh#numberIntersection;++j)
      Isend(processor(prmsh#arrayIntersection[j],prmsh#commddm,rq[j*2]),prfe#snd[j]);
    for(int j=0;j<prmsh#numberIntersection;++j)
      Irecv(processor(prmsh#arrayIntersection[j],prmsh#commddm,rq[j*2+1]),prfe#rcv[j]);
    for(int j=0;j<prmsh#numberIntersection*2;++j)
      int k = mpiWaitAny(rq);
    for(int j=0;j<prmsh#numberIntersection;++j)
      vv += prfe#restrictionIntersection[j]'*prfe#rcv[j];
  }
  return 0;
}

func int prfe#updatematrix(matrix<scalar>& m, bool scale)
{
  if (!prmsh#excluded)
  {
    matrix<scalar>[int] rest(prmsh#arrayIntersection.n);
    matrix<scalar>[int] restSend(prmsh#arrayIntersection.n);

    mpiRequest[int] rq(prmsh#numberIntersection*2);
    for(int j=0;j<prmsh#numberIntersection;++j) {
      restSend[j] = m;
      IFMACRO(prfe#K,real)
      renumbering(restSend[j],prfe#restrictionIntersection[j],eps=-1);
      ENDIFMACRO
      IFMACRO(prfe#K,complex)
      matrix restreal = prfe#restrictionIntersection[j].re;
      renumbering(restSend[j],restreal,eps=-1);
      ENDIFMACRO
      Isend(processor(prmsh#arrayIntersection[j],prmsh#commddm,rq[j*2]),restSend[j]);
    }
    for(int j=0;j<prmsh#numberIntersection;++j)
      Irecv(processor(prmsh#arrayIntersection[j],prmsh#commddm,rq[j*2+1]),rest[j]);
    for(int j=0;j<prmsh#numberIntersection*2;++j)
      int k = mpiWaitAny(rq);
    for(int j=0;j<prmsh#numberIntersection;++j) {
      matrix<scalar> extens = prfe#restrictionIntersection[j]'*rest[j];
      extens = extens*prfe#restrictionIntersection[j];
      m = m + extens;
    }
  }
  return 0;
}

func int prfe#updatematrix(scalar[int,int]& m, bool scale)
{
  if (!prmsh#excluded)
  {
    scalar[int,int][int] rest(prmsh#arrayIntersection.n);
    scalar[int,int][int] restSend(prmsh#arrayIntersection.n);

    mpiRequest[int] rq(prmsh#numberIntersection*2);
    for(int jj=0;jj<prmsh#numberIntersection;++jj) {
      int[int] tI(1), tJ(1);
      scalar[int] tK(1);
      [tI,tJ,tK] = prfe#restrictionIntersection[jj];
      if (tK[tK.n-1] == 0) tJ.resize(tJ.n-1);
      restSend[jj].resize(tJ.n, tJ.n);
      rest[jj].resize(tJ.n, tJ.n);
      for [i,j,aij : restSend[jj]] aij = m(tJ[i],tJ[j]);
      Isend(processor(prmsh#arrayIntersection[jj],prmsh#commddm,rq[jj*2]),restSend[jj]);
    }
    for(int jj=0;jj<prmsh#numberIntersection;++jj)
      Irecv(processor(prmsh#arrayIntersection[jj],prmsh#commddm,rq[jj*2+1]),rest[jj]);
    for(int jj=0;jj<prmsh#numberIntersection*2;++jj)
      int k = mpiWaitAny(rq);
    for(int jj=0;jj<prmsh#numberIntersection;++jj) {
      int[int] tI(1), tJ(1);
      scalar[int] tK(1);
      [tI,tJ,tK] = prfe#restrictionIntersection[jj];
      if (tK[tK.n-1] == 0) tJ.resize(tJ.n-1);
      for [i,j,aij : rest[jj]] m(tJ[i],tJ[j]) += aij;
    }
  }
  return 0;
}

IFMACRO (prfe#myscalprod)
prfe#myscalprod
ENDIFMACRO
IFMACRO (!prfe#myscalprod)
func scalar prfe#scalprod(scalar[int] va, scalar[int] vb)
{
  scalar res = 0;
  if(prmsh#isincomm) {
    /*prmsh#tic(prfe#tloc)*/
    scalar resi = 0;
    if (!bpara) {
      resi = va '* vb;
    }
    else if (!prmsh#excluded){
      scalar[int] sa = va .* prfe#Dk[mpiRank(prmsh#commddm)];
      resi = sa '* vb;
    }
    mpiAllReduce(resi,res,prmsh#mpicomm,mpiSUM);
    /*prmsh#toc(prfe#tloc,"",prfe#tscalprod)*/
  }
  return res;
}
ENDIFMACRO

NewMacro prfe#mplot(u,s)
  if (prmsh#isincomm) {
    if (ffddmbplot) {	
      fespace VhP1(prmsh#Thglob,P1);
      VhP1 solplot;
      if (!bpara) {
        if (mpiRank(prmsh#mpicomm) == 0)
        solplot = u;
      }
      else if (!prmsh#excluded){   
        prmsh#VhiP1 v = u;
        v[] = prmsh#DP1[mpiRank(prmsh#commddm)][].*v[];
        VhP1 tmp;
        tmp[] = prmsh#RihP1[mpiRank(prmsh#commddm)]'*v[];
        solplot[] = 0;
        mpiReduce(tmp[],solplot[],processor(0,prmsh#commddm),mpiSUM);
      }
      if (mpiRank(prmsh#commddm) == 0) {
        if (ffddmbmedit)
        medit(s,prmsh#Thglob,solplot);
        if (ffddmbffplot)
        plot(solplot,dim=3,wait=0,cmm=s,value=1,fill=1,nbiso=ffddmnbiso);
      }
    }
  }
EndMacro

NewMacro prfe#buildtransferfromVhi(VhName,Pknew)
IFMACRO(!prfe#transferMat#VhName#init)
IFMACRO(prfe#K,real)
load "PETSc"
ENDIFMACRO
IFMACRO(prfe#K,complex)
load "PETSc-complex"
ENDIFMACRO
include "macro_ddm.idp"
Mat<prfe#K> prfe#transferMat#VhName;
matrix<prfe#K> prfe#transferMat#VhName#restrict;
ENDIFMACRO

if (prmsh#isincomm)
{
assert(!bnopartloc);
fespace prfe#Phtransfer(prmsh#Thi,P0);
prfe#Phtransfer partkP0;
partkP0[] = prmsh#partloc;
prmsh#meshN Ths = trunc(prmsh#Thi, abs(partkP0 - mpirank) < 1e-2);
reconstructDmesh(Ths)
Mat<prfe#K> Mats;
createMat(Ths, Mats, prfe#fPk)

matrix<prfe#K> At(VhName.ndof, VhName.ndof);
Mat<prfe#K> Matt(At);

prmsh#meshN Thtarget = VhName.Th;

transferMat(Ths, prfe#fPk, Mats, Thtarget, Pknew, Matt, prfe#transferMat#VhName)

fespace prfe#Vhitransfer(Ths,prfe#fPk);
matrix R = interpolate(prfe#Vhitransfer,prfe#Vhi);
prfe#transferMat#VhName#restrict = R;
}

IFMACRO(!prfe#transferMat#VhName#init)
NewMacro prfe#transferMat#VhName#init()1 EndMacro
ENDIFMACRO
EndMacro

NewMacro prfe#transferfromVhi(ui,VhName,Pknew,res)
IFMACRO(!prfe#transferMat#VhName#init)
prfe#buildtransferfromVhi(VhName,Pknew)
ENDIFMACRO

if (prmsh#isincomm)
{
prfe#K[int] rui = prfe#transferMat#VhName#restrict*ui[];
res[] = prfe#transferMat#VhName*rui;
}
EndMacro

NewMacro prfe#feinit()1 EndMacro
ENDIFMACRO
// EOM

macro ffddmbuildDfespacef(prfe,prmsh,scalar,udef,uinit,mPk,udefpart,uinitpart,mPkP0)

ffddminitDfespacef(prfe,prmsh,scalar,udef,uinit,mPk,udefpart,uinitpart,mPkP0)

prfe#Ndofglobal = prfe#Vhglob.ndof;

if (!bpara && ffddmverbosity)
cout << "["+Stringification(prfe)+"] (seqddm) ndof = " << prfe#Ndofglobal << endl;

if (prmsh#isincomm && !prmsh#excluded)
{
  for(int ii=0;ii<prmsh#npart;++ii)
  if ((!bpara) || (ii == mpiRank(prmsh#commddm))) {
    prmsh#Thi = prmsh#aTh[ii];
    fespace Vhipart(prmsh#Thi,prfe#fPkP0);
    Vhipart udefpart(utmp) = uinitpart(prmsh#DP1[ii]);

    Vhipart udefpart(usum);
    if (prmsh#overlap == 0){
      utmp[] = 1;
      usum[] = 1;
    }
    
    if (bpara) {
      int backup = searchMethod;
      searchMethod = 1;
      prfe#rcv.resize(prmsh#numberIntersection);
      prfe#snd.resize(prmsh#numberIntersection);
      prfe#restrictionIntersection.resize(prmsh#numberIntersection);
      for(int i=0;i<prmsh#numberIntersection;++i) {
          matrix R;
          int[int] n2o(1);
          if (prmsh#overlap > 0) {

            IFMACRO(prmsh#partcubes,1)
            fespace Phii(prmsh#Thi,P0);
            Phii parti;
            parti[] = prmsh#partloc;
            prmsh#meshN meshIntersection = trunc(prmsh#Thi, abs(parti - prmsh#arrayIntersection[i]) < 0.1);
            real[int] bb(6);
            boundingbox(meshIntersection,bb);

            IFMACRO(dimension,2)
            real p0x = prmsh#Thi(prmsh#Thi[0][0]).x, p0y = prmsh#Thi(prmsh#Thi[0][0]).y;
            real p1x = prmsh#Thi(prmsh#Thi[0][1]).x, p1y = prmsh#Thi(prmsh#Thi[0][1]).y;
            real p2x = prmsh#Thi(prmsh#Thi[0][2]).x, p2y = prmsh#Thi(prmsh#Thi[0][2]).y;
            real h = min(sqrt((p1x-p0x)^2+(p1y-p0y)^2),sqrt((p2x-p0x)^2+(p2y-p0y)^2));
            bb[0] -= h*prmsh#overlap; bb[2] -= h*prmsh#overlap;
            bb[1] += h*prmsh#overlap; bb[3] += h*prmsh#overlap;
            meshIntersection = trunc(prmsh#Thi, (x>=bb[0])&&(x<=bb[1])&&(y>=bb[2])&&(y<=bb[3]), new2old = n2o, label=9999);
            ENDIFMACRO
            IFMACRO(dimension,3)
            real p0x = prmsh#Thi(prmsh#Thi.be(0)[0]).x, p0y = prmsh#Thi(prmsh#Thi.be(0)[0]).y, p0z = prmsh#Thi(prmsh#Thi.be(0)[0]).z;
            real p1x = prmsh#Thi(prmsh#Thi.be(0)[1]).x, p1y = prmsh#Thi(prmsh#Thi.be(0)[1]).y, p1z = prmsh#Thi(prmsh#Thi.be(0)[1]).z;
            real p2x = prmsh#Thi(prmsh#Thi.be(0)[2]).x, p2y = prmsh#Thi(prmsh#Thi.be(0)[2]).y, p2z = prmsh#Thi(prmsh#Thi.be(0)[2]).z;
            real h = min(sqrt((p1x-p0x)^2+(p1y-p0y)^2+(p1z-p0z)^2), sqrt((p2x-p0x)^2+(p2y-p0y)^2+(p2z-p0z)^2));
            bb[0] -= h*prmsh#overlap; bb[2] -= h*prmsh#overlap; bb[4] -= h*prmsh#overlap;
            bb[1] += h*prmsh#overlap; bb[3] += h*prmsh#overlap; bb[5] += h*prmsh#overlap;
            meshIntersection = trunc(prmsh#Thi, (x>=bb[0])&&(x<=bb[1])&&(y>=bb[2])&&(y<=bb[3])&&(z>=bb[4])&&(z<=bb[5]), new2old = n2o, label=9999);
            ENDIFMACRO

            ENDIFMACRO

            IFMACRO(!prmsh#partcubes)
            prmsh#meshN meshIntersection = trunc(prmsh#Thi, (prmsh#partitionIntersectionbasei[i] > 1.0e-6), new2old = n2o, label=9999);
            ENDIFMACRO

            fespace WhIntersection(meshIntersection, prfe#fPk);
            int[int] renum = restrict(WhIntersection, prfe#Vhi,n2o);
            int[int] Ic = (0:WhIntersection.ndof-1);
            real[int] Kc(WhIntersection.ndof);
            Kc = 1;
            R = [Ic,renum,Kc];
            R.resize(WhIntersection.ndof, prfe#Vhi.ndof);
          }
          else {
            IFMACRO(prmsh#mminoverlap,1)
            matrix RP1 = interpolate(prmsh#VhiP1,prmsh#AugVhiP1);
            prmsh#AugVhiP1 partaugP1;
            partaugP1[] = RP1'*prmsh#partitionIntersectionbasei[i][];
            prmsh#meshN meshIntersection = trunc(prmsh#AugThi, (partaugP1 > 1.0e-6), new2old = n2o);
            fespace prfe#PhAugP0(prmsh#AugThi,P0);
            prfe#PhAugP0 paug;
            paug[] = prmsh#partAug;
            paug = abs(paug-prmsh#arrayIntersection[i]) < 0.1;
            prmsh#meshN meshNeighbor = trunc(prmsh#AugThi, paug > 0.001, label=-10);

            fespace WhIntersection(meshIntersection, prfe#fPkP0);

            fespace WhNeighbor(meshNeighbor, prfe#fPkP0);

            matrix Rn = interpolate(WhNeighbor,prfe#AugVhi,inside=true);

            varf vneighbor(udef(u),udef(v)) = on(-10, udef(u) = uinit(1));
            real[int] bbord = vneighbor(0,WhNeighbor,tgv=1);
            real[int] bbordaug = Rn'*bbord;

            int[int] renum = restrict(WhIntersection, prfe#AugVhi, n2o);

            WhIntersection udefpart(utmpi);

            matrix RR = interpolate(prfe#Vhi,prfe#AugVhi);

            varf vbord(udef(u),udef(v)) = on(ffddminterfacelabel, udef(u) = uinit(1));
            real[int] bmybord = vbord(0,prfe#Vhi,tgv=1);
            real[int] bmybordaug = RR'*bmybord;

            for [i,bi: utmpi[]] bi = (bbordaug[renum[i]] > 0.999 && bmybordaug[renum[i]] > 0.999 ? 1 : 0);

            int[int] rest(WhIntersection.ndof);
            int ninter = 0;
            for (int j=0; j<WhIntersection.ndof; j++)
            if (utmpi[][j] > 0.999)
              rest[ninter++] = renum[j];
            rest.resize(ninter);
            if (ninter > 0){
            int[int] Ic(1);
            if (ninter > 1)
              Ic = (0:ninter-1);
            real[int] Kc(ninter);
            Kc = 1;
            matrix Raug = [Ic,rest,Kc];
            Raug.resize(ninter, prfe#AugVhi.ndof);
            R = Raug*RR';
            usum[] += R'*Kc;
            }
            else {
              R.resize(0, prfe#AugVhi.ndof);
            }
            ENDIFMACRO
            IFMACRO(prmsh#mminoverlap,0)
            cout << "["+Stringification(prfe)+"] ffddmbuildDfespace PB: you need to define macro \""+Stringification(prmsh)+"mminoverlap\" to 1 when using overlap=0, e.g. by adding \"-D"+Stringification(prmsh)+"mminoverlap=1\" to the command line" << endl;
            assert(0);
            ENDIFMACRO
          }

        /*cout << mpirank << " " << prmsh#arrayIntersection[i] << " " << R.n << " " << R.m << endl;*/
        prfe#restrictionIntersection[i] = R;
        prfe#rcv[i].resize(prfe#restrictionIntersection[i].n);
        prfe#snd[i].resize(prfe#restrictionIntersection[i].n);
      }
      searchMethod = backup;
    }

    if (prmsh#overlap == 0)
      utmp[] = utmp[] ./= usum[];

    prfe#Dk[ii].resize(Vhipart.ndof);
    IFMACRO(prfe#K,complex)
    prfe#Dk[ii].re = utmp[];
    ENDIFMACRO
    IFMACRO(prfe#K,real)
    prfe#Dk[ii] = utmp[];
    ENDIFMACRO
    matrix Dihreal = utmp[];
    Dihreal.thresholding(1e-10);
    prfe#Dih[ii] = Dihreal;

    if(!bnoGlob) {
      matrix Rihreal=interpolate(prfe#Vhi,prfe#Vhglob);
      int[int] I(1),J(1);
      real[int] Kc(1);
      [I,J,Kc] = Rihreal;
      for (int i=0;i<Kc.n;i++)
      if (Kc[i] > 0.99)
      Kc[i] = 1.;
      Rihreal = [I,J,Kc];    
      Rihreal.thresholding(1e-10);
      prfe#Rih[ii] = Rihreal;
      prfe#Rih[ii].resize(prfe#Vhi.ndof, prfe#Vhglob.ndof);
    }
    
    if (bseq)
      prmsh#Thi = prmsh#Thglob;
    
    if (bpara)
    {
      func ftest = x+y;
      prfe#Vhi<prfe#K> prfe#mdef(uu), prfe#mdef(vv) = prfe#minit(0.);
      
      uu[] = 1.;
      
      vv[] = prfe#Dk[ii];
      
      prfe#K[int][int] rcv(prmsh#numberIntersection);
      prfe#K[int][int] snd(prmsh#numberIntersection);
      
      mpiRequest[int] rq(prmsh#numberIntersection*2);
      
      
      for(int j=0;j<prmsh#numberIntersection;++j)
      {
        rcv[j].resize(prfe#restrictionIntersection[j].n);
        snd[j].resize(prfe#restrictionIntersection[j].n);
        snd[j] = prfe#restrictionIntersection[j]*vv[];
      }
      
      for(int j=0;j<prmsh#numberIntersection;++j)
      Isend(processor(prmsh#arrayIntersection[j],prmsh#commddm,rq[j*2]),snd[j]);
      for(int j=0;j<prmsh#numberIntersection;++j)
      Irecv(processor(prmsh#arrayIntersection[j],prmsh#commddm,rq[j*2+1]),rcv[j]);
      
      for(int j=0;j<prmsh#numberIntersection*2;++j)
      int k = mpiWaitAny(rq);
      
      for(int j=0;j<prmsh#numberIntersection;++j)
      vv[] += prfe#restrictionIntersection[j]'*rcv[j];
      
      uu[] -= vv[];
      
      if (uu[].linfty > 1.e-8)
      cout << "["+Stringification(prfe)+"] Probleme partition de l'unite : uu[].linfty = " << uu[].linfty << endl;
    }    
    
    if (bpara){
      /* To count the total number of dofs (inspired from statistics hpddm) */
      int ndofglobi=0;
      int[int] table(prfe#Vhi.ndof);
      /* table to label dofs */
      table = ii;
      for(int j=0;j<prmsh#numberIntersection;++j){ /* loop on the neighbors */
        prfe#K[int] C(1);
        int[int] I(1), J(1);
        [I, J, C] = prfe#restrictionIntersection[j]; /* now J is the restrictionIntersection[j] of hpddm */
        if (C[C.n-1] == 0) {
          I.resize(C.n-1);
          J.resize(C.n-1);
          C.resize(C.n-1);
        }
        
        for (int k=0;k<J.n;k++) /* loop on the neighbor dofs */
        table[J[k]] = max(table[J[k]], prmsh#arrayIntersection[j]);
      } 	
      for[i,tablei: table]{ /* syntax for c++ loops */
        if(tablei<=ii) ndofglobi++;
      }
      prfe#Ndofglobal = 0;
      mpiReduce(ndofglobi, prfe#Ndofglobal, processor(0,prmsh#commddm), mpiSUM);
      
      if (ffddmverbosity && mpiRank(prmsh#commddm) == 0)
      cout << "["+Stringification(prfe)+"] (paraddm) ndof = " << prfe#Ndofglobal << endl;
    }	
    
  }
}
// EOM

macro ffddmbuildDfespaceEdge(prfe,prmesh,scalar,def,init,Pk,defpart,initpart,Pkpart)
IFMACRO(prmesh#buildAug,1)
ffddmbuildDfespacef(prfe#Aug,prmesh#Aug,scalar,def,init,Pk,defpart,initpart,Pkpart)
ENDIFMACRO
ffddmbuildDfespacef(prfe,prmesh,scalar,def,init,Pk,defpart,initpart,Pkpart)
IFMACRO(prmesh#buildAug,1)
if (bseq)
  prfe#Auginterp = interpolate(prfe#AugVhi,prfe#Vhglob);
else if (bpara)
  prfe#Auginterp = interpolate(prfe#Vhi,prfe#AugVhi);
prfe#Auginterp.thresholding(1e-10);
ENDIFMACRO
// EOM

macro ffddmbuildDfespace(prfe,prmesh,scalar,def,init,Pk)
ffddmbuildDfespaceEdge(prfe,prmesh,scalar,def,init,Pk,def,init,Pk)
// EOM

macro ffddmbuildDfespaceAug(prfe,prmesh,scalar,def,init,Pk)
ffddmbuildDfespaceEdge(prfe,prmesh,scalar,def,init,Pk,def,init,Pk)
// EOM

macro ffddmbuildDfespaceEdgeAug(prfe,prmesh,scalar,def,init,Pk,defpart,initpart,Pkpart)
ffddmbuildDfespaceEdge(prfe,prmesh,scalar,def,init,Pk,defpart,initpart,Pkpart)
// EOM

macro ffddmbuildDmesh(prmesh,Th,comm)
if ((mpirank == 0) && ffddmverbosity)
cout << "["+Stringification(prmesh)+"] Building decomposition from mesh of " << Th.nt << " elements" << endl;

int prmesh#inexactCSsplit = 0;
int prmesh#binexactCS = 0;
int prmesh#binexactgeneoCS = 0;
int prmesh#pCS = ffddmpCS;
int prmesh#exclude = ffddmexclude;
ffddminitDmeshf(prmesh,comm)

if (!bnoGlob)
if  (prmesh#inexactCSsplit <= 1) {
  if (ffddmsplit == 1)
    prmesh#Thglob = Th;
  else
    prmesh#Thglob = trunc(Th,1,split=ffddmsplit);
}
else 
  prmesh#Thglob = trunc(Th,1,split=prmesh#inexactCSsplit*ffddmsplit);

IFMACRO(!prmesh#mminoverlap)
NewMacro prmesh#mminoverlap()0 EndMacro
ENDIFMACRO

IFMACRO(!prmesh#buildAug)
IFMACRO(prmesh#mminoverlap,1)
NewMacro prmesh#buildAug()1 EndMacro
ENDIFMACRO
ENDIFMACRO

IFMACRO(!prmesh#buildAug)
NewMacro prmesh#buildAug()0 EndMacro
ENDIFMACRO

IFMACRO(prmesh#buildAug,1)
int prmesh#AuginexactCSsplit = 0;
int prmesh#AugbinexactCS = 0;
int prmesh#AugbinexactgeneoCS = 0;
int prmesh#AugpCS = ffddmpCS;
int prmesh#Augexclude = ffddmexclude;
IFMACRO(!prmesh#Augmminoverlap)
NewMacro prmesh#Augmminoverlap()0 EndMacro
ENDIFMACRO
ffddminitDmeshf(prmesh#Aug,comm)

prmesh#AugThglob = prmesh#Thglob;
IFMACRO (!prmesh#AugbuildAug)
NewMacro prmesh#AugbuildAug()0 EndMacro
ENDIFMACRO
ENDIFMACRO

{
  real[int] locpartition;
  ffddmpartf(prmesh,Th,ffddmoverlap,locpartition)
  
  IFMACRO(prmesh#buildAug,1)
  ffddmbuildDmeshf(prmesh#Aug,Th,locpartition,(ffddmoverlap+1))
  ENDIFMACRO

  ffddmbuildDmeshf(prmesh,Th,locpartition,ffddmoverlap)
}
// EOM

macro ffddmbuildDmeshNested(prmesh,Thc,sp,comm)
if ((mpirank == 0) && !bpara)
cout << "["+Stringification(prmesh)+"] ffddmbuildDmeshNested PB: two-level nested mesh decomposition is to be used only in parallel mode" << endl;
assert(bpara);
if ((mpirank == 0) && ffddmverbosity)
cout << "["+Stringification(prmesh)+ "] Building two-level decomposition from coarse mesh of " << Thc.nt << " elements, with splitting parameter " << sp << endl << "["+Stringification(prmesh)+"] Setting binexactCS = 1, pCS = mpisize, exclude = 0" << endl;

int prmesh#inexactCSsplit = sp;
int prmesh#binexactCS = 1;
int prmesh#binexactgeneoCS = 0;
NewMacro prmesh#minexactCS 1 EndMacro
int prmesh#pCS = ffddmpCS;
int prmesh#exclude = ffddmexclude;

int prmesh#CoarseinexactCSsplit = 1;
int prmesh#CoarsebinexactCS = 0;
int prmesh#CoarsebinexactgeneoCS = 0;
int prmesh#CoarsepCS = ffddmpCS;
int prmesh#Coarseexclude = ffddmexclude;

ffddminitDmeshf(prmesh,comm)

if (!bnoGlob)
if  (prmesh#inexactCSsplit <= 1) {
  if (ffddmsplit == 1)
    prmesh#Thglob = Thc;
  else
    prmesh#Thglob = trunc(Thc,1,split=ffddmsplit);
}
else 
  prmesh#Thglob = trunc(Thc,1,split=prmesh#inexactCSsplit*ffddmsplit);

ffddminitDmeshf(prmesh#Coarse,comm)

IFMACRO(!prmesh#mminoverlap)
NewMacro prmesh#mminoverlap()0 EndMacro
ENDIFMACRO

IFMACRO(!prmesh#Coarsemminoverlap)
NewMacro prmesh#Coarsemminoverlap()0 EndMacro
ENDIFMACRO

IFMACRO(!prmesh#buildAug)
NewMacro prmesh#buildAug()0 EndMacro
ENDIFMACRO
IFMACRO(!prmesh#CoarsebuildAug)
NewMacro prmesh#CoarsebuildAug()0 EndMacro
ENDIFMACRO

{
  real[int] partition;
  ffddmpartf(prmesh,Thc,ffddmoverlap,partition)
  ffddmbuildDmeshf(prmesh#Coarse,Thc,partition,ffddmoverlap)
  ffddmbuildDmeshf(prmesh,Thc,partition,ffddmoverlap)
}
// EOM

macro ffddmbuildDmeshAug(prmesh,Th,comm)
IFMACRO(!prmesh#buildAug)
NewMacro prmesh#buildAug()1 EndMacro
ENDIFMACRO
ffddmbuildDmesh(prmesh,Th,comm)
// EOM

macro ffddmbuildDmeshpartcubes(prmesh,Th,comm)
IFMACRO(!prmesh#buildAug)
NewMacro prmesh#partcubes()1 EndMacro
ENDIFMACRO
ffddmbuildDmesh(prmesh,Th,comm)
// EOM

macro ffddmbuildDmeshpartcubesauto(prmesh,N,B,L,comm)
IFMACRO(!prmesh#buildAug)
NewMacro prmesh#partcubes()1 EndMacro
ENDIFMACRO

int prmesh#inexactCSsplit = 0;
int prmesh#binexactCS = 0;
int prmesh#binexactgeneoCS = 0;
int prmesh#pCS = ffddmpCS;
int prmesh#exclude = ffddmexclude;

int prmesh#cubesnpart, prmesh#cubesnx=0, prmesh#cubesny=0, prmesh#cubesnz=0;

{
  int p = mpiSize(comm);

  real nnx = pow(p * N[0]^2 / N[1] / N[2], 1./3.);
  real nny = nnx * N[1] / N[0];
  real nnz = nnx * N[2] / N[0];
  nnx = ceil(nnx); nny = ceil(nny); nnz = ceil(nnz);

  /* try to find the best cuboid partitioning for this number of cores : */
  for (int ii=0; ii<4; ii++)
  for (int jj=0; jj<4; jj++)
  for (int kk=0; kk<4; kk++) {
    int ni = nnx-ii, nj = nny-jj, nk = nnz-kk;
    if (ni*nj*nk <= p && ni*nj*nk > prmesh#cubesnx * prmesh#cubesny * prmesh#cubesnz) {
      prmesh#cubesnx = ni; prmesh#cubesny = nj; prmesh#cubesnz = nk;
    }
  }
  p = prmesh#cubesnx * prmesh#cubesny * prmesh#cubesnz;

  if (mpiRank(comm) == 0) cout << "The domain will be decomposed in " << prmesh#cubesnx << " x " << prmesh#cubesny << " x " << prmesh#cubesnz << " cubic subdomains" << endl;
  if (mpiRank(comm) == 0 && (p != mpiSize(comm)))
    cout << "WARNING: the cuboid decomposition will only use " << p << " of the " << mpiSize(comm) << " available cores" << endl;
  prmesh#cubesnpart = p;
}

/* define sub-communicator if we are not using all cores */
int[int] prmesh#Icubesauto = (0:prmesh#cubesnpart-1);
mpiGroup prmesh#grpcubesauto(prmesh#Icubesauto);
mpiComm prmesh#commcubesauto(comm,prmesh#grpcubesauto);

ffddminitDmeshf(prmesh,prmesh#commcubesauto)

IFMACRO(!prmesh#mminoverlap)
NewMacro prmesh#mminoverlap()0 EndMacro
ENDIFMACRO

IFMACRO(!prmesh#buildAug)
IFMACRO(prmesh#mminoverlap,1)
NewMacro prmesh#buildAug()1 EndMacro
ENDIFMACRO
ENDIFMACRO

IFMACRO(!prmesh#buildAug)
NewMacro prmesh#buildAug()0 EndMacro
ENDIFMACRO

IFMACRO(prmesh#buildAug,1)
int prmesh#AuginexactCSsplit = 0;
int prmesh#AugbinexactCS = 0;
int prmesh#AugbinexactgeneoCS = 0;
int prmesh#AugpCS = ffddmpCS;
int prmesh#Augexclude = ffddmexclude;
IFMACRO(!prmesh#Augmminoverlap)
NewMacro prmesh#Augmminoverlap()0 EndMacro
ENDIFMACRO
ffddminitDmeshf(prmesh#Aug,prmesh#commcubesauto)

prmesh#AugThglob = prmesh#Thglob;
IFMACRO (!prmesh#AugbuildAug)
NewMacro prmesh#AugbuildAug()0 EndMacro
ENDIFMACRO
ENDIFMACRO

if (prmesh#isincomm)
{
  int nx = prmesh#cubesnx, ny = prmesh#cubesny, nz = prmesh#cubesnz;
  int zx = nx - (N[0]%nx), zy = ny - (N[1]%ny), zz = nz - (N[2]%nz);
  int px = ceil(1.*N[0]/nx), py = ceil(1.*N[1]/ny), pz = ceil(1.*N[2]/nz);

  if (mpiRank(prmesh#commcubesauto) == 0) cout << "Subdomain size " << px+1 << " x " << py+1 << " x " << pz+1 << endl;

  int boundzl = mpiRank(prmesh#commcubesauto) / ( nx * ny );
  int nr = mpiRank(prmesh#commcubesauto) - boundzl * nx * ny;
  int boundyl = nr / nx;
  int boundxl = nr % nx;

  boundxl *= px; boundyl *= py; boundzl *= pz;

  int boundzu = (mpiRank(prmesh#commcubesauto) / ( nx * ny ) < nz - 1 ? boundzl + pz - 1 : N[2]-1);
  int boundyu = (nr / nx < ny - 1 ? boundyl + py - 1 : N[1] - 1);
  int boundxu = (nr % nx < nx - 1 ? boundxl + px - 1 : N[0] - 1);

  boundxl = max(0,boundxl-3*ffddmoverlap); boundxu = min(N[0]-1,boundxu+3*ffddmoverlap);
  boundyl = max(0,boundyl-3*ffddmoverlap); boundyu = min(N[1]-1,boundyu+3*ffddmoverlap);
  boundzl = max(0,boundzl-3*ffddmoverlap); boundzu = min(N[2]-1,boundzu+3*ffddmoverlap);

  int nbnx = boundxu-boundxl+1;
  int nbny = boundyu-boundyl+1;
  int nbnz = boundzu-boundzl+1;

  /* truncate global grid around the subdomain before partitioning to avoid defining the full grid */
  real h = (B(0,1)-B(0,0))/N[0];
  int[int] NN=[nbnx,nbny,nbnz];

  real [int,int] BB=[[B(0,0)+boundxl*h,B(0,0)+(boundxu+1)*h],[B(1,0)+boundyl*h,B(1,0)+(boundyu+1)*h],[B(2,0)+boundzl*h,B(2,0)+(boundzu+1)*h]];
  int [int,int] LL=[[L(0,0)+100*(boundxl!=0),L(0,1)+100*(boundxu!=N[0]-1)],[L(1,0)+100*(boundyl!=0),L(1,1)+100*(boundyu!=N[1]-1)],[L(2,0)+100*(boundzl!=0),L(2,1)+100*(boundzu!=N[2]-1)]];

  mesh3 Thtcube = Cube(NN,BB,LL);

  func int partcube(int ii, int jj, int kk) {
    return min(kk / pz, int(nz-1))*nx*ny + min(jj / py, int(ny-1))*nx + min(ii / px, int(nx-1));
  }

  fespace prmesh#Phgcube(Thtcube,P0);
  prmesh#Phgcube partglob;

  /* define the regular partitioning as a P0 function on Th */
  partglob=partcube(floor((x-B(0,0))/(B(0,1)-B(0,0))*N[0]), floor((y-B(1,0))/(B(1,1)-B(1,0))*N[1]), floor((z-B(2,0))/(B(2,1)-B(2,0))*N[2]));

  ffddmbuildDmeshf(prmesh,Thtcube,partglob[],ffddmoverlap)
}
// EOM

macro ffddmbuildDfespaceEdgeNested(prfe,prmesh,scalar,def,init,Pk,defpart,initpart,Pkpart)
ffddmbuildDfespaceEdge(prfe#Coarse,prmesh#Coarse,scalar,def,init,Pk,defpart,initpart,Pkpart)
ffddmbuildDfespaceEdge(prfe,prmesh,scalar,def,init,Pk,defpart,initpart,Pkpart)
// EOM

macro ffddmbuildDfespaceNested(prfe,prmesh,scalar,def,init,Pk)
ffddmbuildDfespaceEdgeNested(prfe,prmesh,scalar,def,init,Pk,def,init,Pk)
// EOM

macro ffddmbuild(pr,Th,scalar,def,init,Pk,comm)
ffddmbuildDmesh(pr,Th,comm)
ffddmbuildDfespace(pr,pr,scalar,def,init,Pk)
// EOM

macro ffddmbuildEdge(pr,Th,scalar,def,init,Pk,defpart,initpart,Pkpart,comm)
ffddmbuildDmesh(pr,Th,comm)
ffddmbuildDfespaceEdge(pr,pr,scalar,def,init,Pk,defpart,initpart,Pkpart)
// EOM

macro ffddmbuildEdgeNested(pr,Thc,sp,scalar,def,init,Pk,defpart,initpart,Pkpart,comm)
ffddmbuildDmeshNested(pr,Thc,sp,comm)
ffddmbuildDfespaceEdgeNested(pr,pr,scalar,def,init,Pk,defpart,initpart,Pkpart)
// EOM

macro ffddmbuildNested(pr,Thc,sp,scalar,def,init,Pk,comm)
ffddmbuildEdgeNested(pr,Thc,sp,scalar,def,init,Pk,def,init,Pk,comm)
// EOM

macro ffddmbuildEdgeAug(pr,Th,scalar,def,init,Pk,defpart,initpart,PkP0,comm)
IFMACRO(!pr#buildAug)
NewMacro pr#buildAug()1 EndMacro
ENDIFMACRO
ffddmbuildEdge(pr,Th,scalar,def,init,Pk,defpart,initpart,PkP0,comm) // EOM

macro ffddmbuildAug(pr,Th,scalar,def,init,Pk,comm)
ffddmbuildEdgeAug(pr,Th,scalar,def,init,Pk,def,init,Pk,comm) // EOM

/*
macro ffddmbuildEdge(pr,Th,scalar,def,init,Pk,defpart,initpart,PkP0,comm)
if ((mpirank == 0) && ffddmverbosity)
cout << "Building decomposition from mesh of " << Th.nt << " elements" << endl;
int pr#inexactCSsplit = 0;
int pr#binexactCS = 0;
int pr#pCS = ffddmpCS;
int pr#exclude = ffddmexclude;
ffddminitf(pr,Th,scalar,def,init,Pk,defpart,initpart,PkP0,comm)

IFMACRO(pr#buildAug,1)
int pr#AuginexactCSsplit = 0;
int pr#AugbinexactCS = 0;
int pr#AugpCS = ffddmpCS;
int pr#Augexclude = ffddmexclude;
ffddminitf(pr#Aug,Th,scalar,def,init,Pk,defpart,initpart,PkP0,comm)
pr#Augverbosity = pr#verbosity;
ENDIFMACRO

{
real[int] partition;
ffddmpartf(pr,Th,partition)
ffddmbuildf(pr,Th,partition)

IFMACRO(pr#buildAug,1)
ffddmoverlap += 1;
ffddmbuildf(pr#Aug,Th,partition)
ffddmoverlap -= 1;
ENDIFMACRO
}

IFMACRO(pr#buildAug,1)
if (bseq)
pr#Auginterp = interpolate(pr#AugVhi,pr#Vhglob);
else if (bpara)
pr#Auginterp = interpolate(pr#Vhi,pr#AugVhi);
ENDIFMACRO
// EOM

macro ffddmbuild(pr,Th,scalar,def,init,Pk,comm)
ffddmbuildEdge(pr,Th,scalar,def,init,Pk,def,init,Pk,comm) // EOM

macro ffddmbuildaugEdge(pr,Th,scalar,def,init,Pk,defpart,initpart,PkP0,comm)
NewMacro pr#buildAug()1 EndMacro
ffddmbuildEdge(pr,Th,scalar,def,init,Pk,defpart,initpart,PkP0,comm) // EOM

macro ffddmbuildaug(pr,Th,scalar,def,init,Pk,comm)
ffddmbuildaugEdge(pr,Th,scalar,def,init,Pk,def,init,Pk,comm) // EOM

macro ffddmbuildNestedEdge(pr,Thc,sp,scalar,def,init,Pk,defpart,initpart,PkP0,comm)
if ((mpirank == 0) && !bpara)
cout << "ffddmbuildNestedEdge PB: two-level nested mesh decomposition is to be used only in parallel mode" << endl;
assert(bpara);
if ((mpirank == 0) && ffddmverbosity)
cout << "Building nested decomposition from coarse mesh of " << Thc.nt << " elements, with splitting parameter " << sp << endl << "Setting binexactCS = 1, pCS = mpisize, exclude = 0 for prefix \""+Stringification(pr)+"\"" << endl;

int pr#inexactCSsplit = sp;
int pr#binexactCS = 1;
NewMacro pr#minexactCS 1 EndMacro
int pr#pCS = ffddmpCS;
int pr#exclude = ffddmexclude;

int pr#CoarseinexactCSsplit = 1;
int pr#CoarsebinexactCS = 0;
int pr#CoarsepCS = ffddmpCS;
int pr#Coarseexclude = ffddmexclude;

ffddminitf(pr#Coarse,Thc,scalar,def,init,Pk,defpart,initpart,PkP0,comm)
ffddminitf(pr,Thc,scalar,def,init,Pk,defpart,initpart,PkP0,comm)

{
real[int] partition;
ffddmpartf(pr,Thc,partition)
ffddmbuildf(pr#Coarse,Thc,partition)
ffddmbuildf(pr,Thc,partition)
}

pr#Coarseverbosity = 1;

// EOM

macro ffddmbuildNested(pr,Thc,sp,scalar,def,init,Pk,comm) ffddmbuildNestedEdge(pr,Thc,sp,scalar,def,init,Pk,def,init,Pk,comm) // EOM
*/
